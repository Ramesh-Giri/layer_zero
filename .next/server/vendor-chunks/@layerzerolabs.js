"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@layerzerolabs";
exports.ids = ["vendor-chunks/@layerzerolabs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@layerzerolabs/lz-v2-utilities/dist/index.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@layerzerolabs/lz-v2-utilities/dist/index.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar address = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/@ethersproject/address/lib.esm/index.js\");\nvar bytes = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\nvar web3_js = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\");\nvar abi = __webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/@ethersproject/abi/lib.esm/index.js\");\nvar bignumber = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/index.js\");\nvar solidity = __webpack_require__(/*! @ethersproject/solidity */ \"(ssr)/./node_modules/@ethersproject/solidity/lib.esm/index.js\");\nvar invariant = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js\");\nvar keccak256 = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n\nfunction _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }\n\nvar invariant__default = /*#__PURE__*/_interopDefault(invariant);\n\n// src/utils/hex.ts\nfunction hexZeroPadTo32(addr) {\n  return bytes.hexZeroPad(addr, 32);\n}\nfunction bytes32ToEthAddress(bytes32) {\n  if (bytes32 instanceof Uint8Array) {\n    bytes32 = bytes.hexlify(bytes32);\n  }\n  return address.getAddress(bytes32.slice(-40));\n}\nfunction trim0x(str) {\n  return str.replace(/^0x/, \"\");\n}\nfunction addressToBytes32(address) {\n  if (isSolanaAddress(address)) {\n    return new web3_js.PublicKey(address).toBytes();\n  } else if (address.startsWith(\"0x\") && address.length <= 66) {\n    return bytes.arrayify(hexZeroPadTo32(address));\n  }\n  throw new Error(\"Invalid address\");\n}\nvar solanaAddressRegex = /^([1-9A-HJ-NP-Za-km-z]{32,44})$/;\nfunction isSolanaAddress(address) {\n  return solanaAddressRegex.test(address);\n}\n\n// src/utils/precrime.ts\nvar CONFIG_VERSION_OFFSET = 0;\nvar MAX_BATCH_SIZE_OFFSET = 2;\nvar NUMBER_OF_PEERS_OFFSET = 10;\nvar PEERS_OFFSET = 12;\nfunction parsePrecrimeConfig(precrimeConfig) {\n  const data = trim0x(precrimeConfig);\n  const version = parseInt(data.slice(0, 4), 16);\n  if (version === 1) {\n    return parsePrecrimeConfigV1(precrimeConfig);\n  } else if (version === 2) {\n    return parsePrecrimeConfigV2(precrimeConfig);\n  }\n  throw new Error(`Unsupported precrime config version: ${version}`);\n}\nfunction parsePrecrimeConfigV1(precrimeConfig) {\n  const data = trim0x(precrimeConfig);\n  const version = parseInt(data.slice(0, 4), 16);\n  const maxBatchSize = parseInt(data.slice(4, 20), 16);\n  const remoteChainsLength = parseInt(data.slice(20, 84), 16);\n  const remoteChainsBytes = data.slice(84, 84 + remoteChainsLength * 64);\n  const remoteAddressesBytes = data.slice(\n    84 + remoteChainsLength * 64,\n    84 + remoteChainsLength * 64 + remoteChainsLength * 64\n  );\n  const remoteChainsBytesArray = [];\n  const remoteAddressesBytesArray = [];\n  let start = 0;\n  let end = 64;\n  for (let i = 0; i < remoteChainsLength; i++) {\n    remoteChainsBytesArray.push(parseInt(remoteChainsBytes.slice(start, end), 16));\n    remoteAddressesBytesArray.push(`0x${remoteAddressesBytes.slice(start, end)}`);\n    start += 64;\n    end += 64;\n  }\n  return { version, maxBatchSize, remoteEids: remoteChainsBytesArray, remoteAddresses: remoteAddressesBytesArray };\n}\nfunction parsePrecrimeConfigV2(precrimeConfig) {\n  const buffer = Buffer.from(trim0x(precrimeConfig), \"hex\");\n  const version = buffer.readUInt16BE(CONFIG_VERSION_OFFSET);\n  const maxBatchSize = buffer.readBigUint64BE(MAX_BATCH_SIZE_OFFSET);\n  const peers = new Array();\n  if (buffer.length > NUMBER_OF_PEERS_OFFSET) {\n    const numOfPeers = buffer.readUInt16BE(NUMBER_OF_PEERS_OFFSET);\n    for (let i = 0; i < numOfPeers; i++) {\n      const offset = PEERS_OFFSET + i * (4 + 2 * 32);\n      const eid = buffer.readUInt32BE(offset);\n      const preCrimeAddress = \"0x\" + buffer.slice(offset + 4, offset + 4 + 32).toString(\"hex\");\n      const oappAddress = \"0x\" + buffer.slice(offset + 4 + 32, offset + 4 + 32 + 32).toString(\"hex\");\n      peers.push({\n        eid,\n        preCrimeAddress,\n        oappAddress\n      });\n    }\n  }\n  return {\n    version,\n    maxBatchSize,\n    peers\n  };\n}\nvar parseError = (errorData, intf) => {\n  const buildInError = parseBuildInError(errorData);\n  if (buildInError !== void 0) {\n    return buildInError;\n  }\n  if (intf) {\n    try {\n      return intf.parseError(errorData);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n};\nfunction parseBuildInError(errorData) {\n  if (errorData.startsWith(\"0x08c379a0\")) {\n    const content = `0x${errorData.substring(10)}`;\n    const reason = abi.defaultAbiCoder.decode([\"string\"], content);\n    return reason[0];\n  }\n  if (errorData.startsWith(\"0x4e487b71\")) {\n    const content = `0x${errorData.substring(10)}`;\n    const code = abi.defaultAbiCoder.decode([\"uint\"], content);\n    return code[0];\n  }\n  if (errorData === \"0x\") {\n    return \"\";\n  }\n}\nvar OptionType = /* @__PURE__ */ ((OptionType2) => {\n  OptionType2[OptionType2[\"TYPE_1\"] = 1] = \"TYPE_1\";\n  OptionType2[OptionType2[\"TYPE_2\"] = 2] = \"TYPE_2\";\n  OptionType2[OptionType2[\"TYPE_3\"] = 3] = \"TYPE_3\";\n  return OptionType2;\n})(OptionType || {});\nvar MAX_UINT_128 = bignumber.BigNumber.from(\"0xffffffffffffffffffffffffffffffff\");\nfunction optionsType1(_extraGas) {\n  const extraGas = bignumber.BigNumber.from(_extraGas);\n  invariant__default.default(extraGas.lte(MAX_UINT_128), \"extraGas should be less than MAX_UINT_128\");\n  return solidity.pack([\"uint16\", \"uint256\"], [1 /* TYPE_1 */, extraGas]);\n}\nfunction optionsType2(_extraGas, _dstNativeAmt, _dstNativeAddress) {\n  const extraGas = bignumber.BigNumber.from(_extraGas);\n  invariant__default.default(extraGas.lte(MAX_UINT_128), \"extraGas should be less than MAX_UINT_128\");\n  const dstNativeAmt = bignumber.BigNumber.from(_dstNativeAmt);\n  invariant__default.default(dstNativeAmt.lte(MAX_UINT_128), \"dstNativeAmt should be less than MAX_UINT_128\");\n  return solidity.pack(\n    [\"uint16\", \"uint256\", \"uint256\", \"bytes\"],\n    [2 /* TYPE_2 */, bignumber.BigNumber.from(extraGas), bignumber.BigNumber.from(dstNativeAmt), _dstNativeAddress]\n  );\n}\nvar WorkerId = /* @__PURE__ */ ((WorkerId2) => {\n  WorkerId2[WorkerId2[\"EXECUTOR\"] = 1] = \"EXECUTOR\";\n  WorkerId2[WorkerId2[\"VERIFIER\"] = 2] = \"VERIFIER\";\n  WorkerId2[WorkerId2[\"TREASURY\"] = 255] = \"TREASURY\";\n  return WorkerId2;\n})(WorkerId || {});\nvar ExecutorOptionType = /* @__PURE__ */ ((ExecutorOptionType2) => {\n  ExecutorOptionType2[ExecutorOptionType2[\"LZ_RECEIVE\"] = 1] = \"LZ_RECEIVE\";\n  ExecutorOptionType2[ExecutorOptionType2[\"NATIVE_DROP\"] = 2] = \"NATIVE_DROP\";\n  ExecutorOptionType2[ExecutorOptionType2[\"COMPOSE\"] = 3] = \"COMPOSE\";\n  ExecutorOptionType2[ExecutorOptionType2[\"ORDERED\"] = 4] = \"ORDERED\";\n  return ExecutorOptionType2;\n})(ExecutorOptionType || {});\nvar VerifierOptionType = /* @__PURE__ */ ((VerifierOptionType2) => {\n  VerifierOptionType2[VerifierOptionType2[\"PRECRIME\"] = 1] = \"PRECRIME\";\n  return VerifierOptionType2;\n})(VerifierOptionType || {});\nvar Options = class _Options {\n  workerOptions = [];\n  // dissuade public instantiation\n  constructor() {\n  }\n  /**\n   * Create a new options instance.\n   */\n  static newOptions() {\n    return new _Options();\n  }\n  /**\n   * Create an options instance from a hex string.\n   * @param {string} optionsHex The hex string to decode.\n   */\n  static fromOptions(optionsHex) {\n    const options = new _Options();\n    const optionsBytes = bytes.arrayify(optionsHex);\n    const optionsType = bignumber.BigNumber.from(optionsBytes.slice(0, 2)).toNumber();\n    if (optionsType === 3 /* TYPE_3 */) {\n      let cursor = 2;\n      while (cursor < optionsBytes.byteLength) {\n        const workerId = bignumber.BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber();\n        cursor += 1;\n        const size = bignumber.BigNumber.from(optionsBytes.slice(cursor, cursor + 2)).toNumber();\n        cursor += 2;\n        if (workerId === 1 /* EXECUTOR */) {\n          const optionType = bignumber.BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber();\n          cursor += 1;\n          const params = optionsBytes.slice(cursor, cursor + size - 1);\n          cursor += size - 1;\n          options.addOption(workerId, { type: optionType, params: bytes.hexlify(params) });\n        } else if (workerId === 2 /* VERIFIER */) {\n          const verifierIdx = bignumber.BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber();\n          cursor += 1;\n          const optionType = bignumber.BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber();\n          cursor += 1;\n          const params = optionsBytes.slice(cursor, cursor + size - 2);\n          cursor += size - 2;\n          options.addOption(workerId, {\n            type: optionType,\n            index: verifierIdx,\n            params: bytes.hexlify(params)\n          });\n        }\n      }\n    } else if (optionsType === 2 /* TYPE_2 */) {\n      const extraGas = bignumber.BigNumber.from(optionsBytes.slice(2, 34)).toBigInt();\n      const dstNativeAmt = bignumber.BigNumber.from(optionsBytes.slice(34, 66)).toBigInt();\n      const dstNativeAddress = bytes.hexlify(optionsBytes.slice(66, optionsBytes.byteLength));\n      options.addExecutorLzReceiveOption(extraGas).addExecutorNativeDropOption(dstNativeAmt, dstNativeAddress);\n    } else if (optionsType === 1 /* TYPE_1 */) {\n      const extraGas = bignumber.BigNumber.from(optionsBytes.slice(2, 34)).toBigInt();\n      options.addExecutorLzReceiveOption(extraGas);\n    }\n    return options;\n  }\n  /**\n   * Add ExecutorOptionType.LZ_RECEIVE option.\n   * @param {GasLimit} gasLimit\n   * @param {NativeDrop} nativeDrop\n   */\n  addExecutorLzReceiveOption(gasLimit, nativeDrop = 0) {\n    const gasLimitBN = bignumber.BigNumber.from(gasLimit);\n    invariant__default.default(gasLimitBN.lte(MAX_UINT_128), \"gasLimit shouldn't be greater than MAX_UINT_128\");\n    const nativeDropBN = bignumber.BigNumber.from(nativeDrop);\n    invariant__default.default(nativeDropBN.lte(MAX_UINT_128), \"value shouldn't be greater than MAX_UINT_128\");\n    this.addOption(1 /* EXECUTOR */, {\n      type: 1 /* LZ_RECEIVE */,\n      params: nativeDropBN.eq(0) ? solidity.pack([\"uint128\"], [gasLimitBN]) : solidity.pack([\"uint128\", \"uint128\"], [gasLimitBN, nativeDropBN])\n    });\n    return this;\n  }\n  /**\n   * Add ExecutorOptionType.NATIVE_DROP option.\n   * @param {NativeDrop} nativeDrop\n   * @param {string} receiver\n   */\n  addExecutorNativeDropOption(nativeDrop, receiver) {\n    const amountBN = bignumber.BigNumber.from(nativeDrop);\n    invariant__default.default(amountBN.lte(MAX_UINT_128), \"nativeDrop shouldn't be greater than MAX_UINT_128\");\n    this.addOption(1 /* EXECUTOR */, {\n      type: 2 /* NATIVE_DROP */,\n      params: solidity.pack([\"uint128\", \"bytes32\"], [amountBN, hexZeroPadTo32(receiver)])\n    });\n    return this;\n  }\n  /**\n   * Add ExecutorOptionType.COMPOSE option.\n   * @param {number} index\n   * @param {GasLimit} gasLimit\n   * @param {NativeDrop} nativeDrop\n   */\n  addExecutorComposeOption(index, gasLimit, nativeDrop = 0) {\n    const gasLimitBN = bignumber.BigNumber.from(gasLimit);\n    invariant__default.default(gasLimitBN.lte(MAX_UINT_128), \"gasLimit shouldn't be greater than MAX_UINT_128\");\n    const nativeDropBN = bignumber.BigNumber.from(nativeDrop);\n    invariant__default.default(nativeDropBN.lte(MAX_UINT_128), \"nativeDrop shouldn't be greater than MAX_UINT_128\");\n    const option = nativeDropBN.gt(0) ? {\n      type: 3 /* COMPOSE */,\n      params: solidity.pack([\"uint16\", \"uint128\", \"uint128\"], [index, gasLimitBN, nativeDropBN])\n    } : {\n      type: 3 /* COMPOSE */,\n      params: solidity.pack([\"uint16\", \"uint128\"], [index, gasLimitBN])\n    };\n    this.addOption(1 /* EXECUTOR */, option);\n    return this;\n  }\n  /**\n   * Add ExecutorOptionType.ORDERED option.\n   */\n  addExecutorOrderedExecutionOption() {\n    this.addOption(1 /* EXECUTOR */, {\n      type: 4 /* ORDERED */,\n      params: \"0x\"\n    });\n    return this;\n  }\n  /**\n   * Add VerifierOptionType.PRECRIME option.\n   * @param {number} verifierIdx\n   */\n  addVerifierPrecrimeOption(verifierIdx) {\n    this.addOption(2 /* VERIFIER */, {\n      type: 1 /* PRECRIME */,\n      index: verifierIdx,\n      params: \"0x\"\n    });\n    return this;\n  }\n  /**\n   * Serialize Options to hex string.\n   */\n  toHex() {\n    let hex = solidity.pack([\"uint16\"], [3 /* TYPE_3 */]);\n    this.workerOptions.forEach((w) => {\n      for (const option of w.options) {\n        if (w.workerId === 1 /* EXECUTOR */) {\n          hex += trim0x(\n            solidity.pack(\n              [\"uint8\", \"uint16\", \"uint8\", \"bytes\"],\n              [w.workerId, trim0x(option.params).length / 2 + 1, option.type, option.params]\n            )\n          );\n        } else if (w.workerId === 2 /* VERIFIER */) {\n          const verifierOption = option;\n          hex += trim0x(\n            solidity.pack(\n              [\"uint8\", \"uint16\", \"uint8\", \"uint8\", \"bytes\"],\n              [\n                w.workerId,\n                trim0x(option.params).length / 2 + 2,\n                verifierOption.index,\n                verifierOption.type,\n                verifierOption.params\n              ]\n            )\n          );\n        }\n      }\n    });\n    return hex;\n  }\n  /**\n   * Serialize Options to Uint8Array.\n   */\n  toBytes() {\n    return bytes.arrayify(this.toHex());\n  }\n  addOption(workerId, option) {\n    const worker = this.workerOptions.find((w) => w.workerId === workerId);\n    if (worker) {\n      worker.options.push(option);\n    } else {\n      this.workerOptions.push({ workerId, options: [option] });\n    }\n  }\n  /**\n   * Decode ExecutorOptionType.LZ_RECEIVE option.  Returns undefined if the option is not present.\n   */\n  decodeExecutorLzReceiveOption() {\n    const options = this.findOptions(1 /* EXECUTOR */, 1 /* LZ_RECEIVE */);\n    if (!options || options.length === 0) {\n      return;\n    }\n    let totalGas = bignumber.BigNumber.from(0).toBigInt();\n    let totalValue = bignumber.BigNumber.from(0).toBigInt();\n    for (const option of options) {\n      const buffer = Buffer.from(trim0x(option.params), \"hex\");\n      const gas = bignumber.BigNumber.from(buffer.subarray(0, 16)).toBigInt();\n      const value = bignumber.BigNumber.from(buffer.length === 16 ? 0 : buffer.subarray(16, 32)).toBigInt();\n      totalGas = totalGas + gas;\n      totalValue = totalValue + value;\n    }\n    return { gas: totalGas, value: totalValue };\n  }\n  /**\n   * Decode ExecutorOptionType.NATIVE_DROP options.  Returns undefined if the options is not present.\n   */\n  decodeExecutorNativeDropOption() {\n    const options = this.findOptions(1 /* EXECUTOR */, 2 /* NATIVE_DROP */);\n    if (!options || options.length === 0) {\n      return [];\n    }\n    const results = options.reduce((acc, cur) => {\n      const buffer = Buffer.from(trim0x(cur.params), \"hex\");\n      const amount = bignumber.BigNumber.from(buffer.subarray(0, 16)).toBigInt();\n      const receiver = bytes.hexlify(buffer.subarray(16, 48));\n      if (acc[receiver]) {\n        acc[receiver][\"amount\"] = acc[receiver].amount + amount;\n      } else {\n        acc[receiver] = { amount, receiver };\n      }\n      return acc;\n    }, {});\n    return Object.values(results);\n  }\n  /**\n   * Decode ExecutorOptionType.COMPOSE options.  Returns undefined if the options is not present.\n   */\n  decodeExecutorComposeOption() {\n    const options = this.findOptions(1 /* EXECUTOR */, 3 /* COMPOSE */);\n    if (!options || options.length === 0) {\n      return [];\n    }\n    const results = options.reduce(\n      (acc, cur) => {\n        const buffer = Buffer.from(trim0x(cur.params), \"hex\");\n        const index = bignumber.BigNumber.from(buffer.subarray(0, 2)).toNumber();\n        const gas = bignumber.BigNumber.from(buffer.subarray(2, 18)).toBigInt();\n        const value = (buffer.length === 34 ? bignumber.BigNumber.from(buffer.subarray(18, 34)) : bignumber.BigNumber.from(0)).toBigInt();\n        if (acc[index]) {\n          acc[index][\"gas\"] = acc[index].gas + gas;\n          acc[index][\"value\"] = acc[index].value + value;\n        } else {\n          acc[index] = { index, gas, value };\n        }\n        return acc;\n      },\n      {}\n    );\n    return Object.values(results);\n  }\n  /**\n   * Decode ExecutorOptionType.ORDERED options.  Returns undefined if the options is not present.\n   */\n  decodeExecutorOrderedExecutionOption() {\n    const option = this.findOptions(1 /* EXECUTOR */, 4 /* ORDERED */);\n    return option !== void 0;\n  }\n  findOptions(workerId, optionType) {\n    const worker = this.workerOptions.find((w) => w.workerId === workerId);\n    if (worker) {\n      if (optionType === 4 /* ORDERED */) {\n        return worker.options.find((o) => o.type === optionType);\n      }\n      return worker.options.filter((o) => o.type === optionType);\n    }\n  }\n  /**\n   * Find VerifierOption by verifierIdx and optionType.  Returns undefined if the option is not present.\n   * @param {number} verifierIdx\n   * @param {number} optionType\n   */\n  findVerifierOption(verifierIdx, optionType) {\n    const worker = this.workerOptions.find((w) => w.workerId === 2 /* VERIFIER */);\n    if (worker) {\n      const opt = worker.options.find((o) => o.type === optionType && o.index === verifierIdx);\n      if (opt) {\n        return opt;\n      }\n    }\n  }\n};\n\n// src/model/packet.ts\nfunction packetToMessageOrigin(packet) {\n  return {\n    srcEid: packet.srcEid,\n    sender: packet.sender,\n    nonce: packet.nonce\n  };\n}\nvar PACKET_VERSION_OFFSET = 0;\nvar NONCE_OFFSET = 1;\nvar SRC_CHAIN_OFFSET = 9;\nvar SRC_ADDRESS_OFFSET = 13;\nvar DST_CHAIN_OFFSET = 45;\nvar DST_ADDRESS_OFFSET = 49;\nvar GUID_OFFSET = 81;\nvar MESSAGE_OFFSET = 113;\nvar PacketV1Codec = class _PacketV1Codec {\n  buffer;\n  static from(payloadEncoded) {\n    return new _PacketV1Codec(payloadEncoded);\n  }\n  static fromBytes(payload) {\n    return new _PacketV1Codec(\"0x\" + Buffer.from(payload).toString(\"hex\"));\n  }\n  constructor(payloadEncoded) {\n    this.buffer = Buffer.from(trim0x(payloadEncoded), \"hex\");\n  }\n  /**\n   * encode packet to hex string\n   */\n  static encode(packet) {\n    const message = trim0x(packet.message);\n    const buffer = Buffer.alloc(MESSAGE_OFFSET + message.length / 2);\n    buffer.writeUInt8(packet.version, PACKET_VERSION_OFFSET);\n    buffer.writeBigUInt64BE(BigInt(packet.nonce), NONCE_OFFSET);\n    buffer.writeUInt32BE(packet.srcEid, SRC_CHAIN_OFFSET);\n    buffer.write(trim0x(hexZeroPadTo32(packet.sender)), SRC_ADDRESS_OFFSET, 32, \"hex\");\n    buffer.writeUInt32BE(packet.dstEid, DST_CHAIN_OFFSET);\n    buffer.write(trim0x(hexZeroPadTo32(packet.receiver)), DST_ADDRESS_OFFSET, 32, \"hex\");\n    buffer.write(trim0x(packet.guid), GUID_OFFSET, 32, \"hex\");\n    buffer.write(message, MESSAGE_OFFSET, message.length / 2, \"hex\");\n    return \"0x\" + buffer.toString(\"hex\");\n  }\n  version() {\n    return this.buffer.readUInt8(PACKET_VERSION_OFFSET);\n  }\n  nonce() {\n    return this.buffer.readBigUint64BE(NONCE_OFFSET).toString();\n  }\n  srcEid() {\n    return this.buffer.readUint32BE(SRC_CHAIN_OFFSET);\n  }\n  sender() {\n    return \"0x\" + this.buffer.slice(SRC_ADDRESS_OFFSET, DST_CHAIN_OFFSET).toString(\"hex\");\n  }\n  senderAddressB20() {\n    return bytes32ToEthAddress(this.sender());\n  }\n  dstEid() {\n    return this.buffer.readUint32BE(DST_CHAIN_OFFSET);\n  }\n  receiver() {\n    return \"0x\" + this.buffer.slice(DST_ADDRESS_OFFSET, GUID_OFFSET).toString(\"hex\");\n  }\n  receiverAddressB20() {\n    return bytes32ToEthAddress(this.receiver());\n  }\n  guid() {\n    return \"0x\" + this.buffer.slice(GUID_OFFSET, MESSAGE_OFFSET).toString(\"hex\");\n  }\n  message() {\n    return \"0x\" + this.buffer.slice(MESSAGE_OFFSET).toString(\"hex\");\n  }\n  payloadHash() {\n    return keccak256.keccak256(this.payload());\n  }\n  payload() {\n    return \"0x\" + this.buffer.slice(GUID_OFFSET).toString(\"hex\");\n  }\n  header() {\n    return \"0x\" + this.buffer.slice(0, GUID_OFFSET).toString(\"hex\");\n  }\n  headerHash() {\n    return keccak256.keccak256(this.header());\n  }\n  /**\n   * deserialize packet from hex string\n   * @deprecated use toPacket instead\n   */\n  decode() {\n    return this.toPacket();\n  }\n  toPacket() {\n    return {\n      version: this.version(),\n      nonce: this.nonce(),\n      srcEid: this.srcEid(),\n      sender: this.sender(),\n      dstEid: this.dstEid(),\n      receiver: this.receiver(),\n      guid: this.guid(),\n      message: this.message(),\n      // derived\n      payload: this.payload()\n    };\n  }\n};\nfunction calculateGuid(packetHead) {\n  return keccak256.keccak256(\n    solidity.pack(\n      [\"uint64\", \"uint32\", \"bytes32\", \"uint32\", \"bytes32\"],\n      [\n        bignumber.BigNumber.from(packetHead.nonce),\n        packetHead.srcEid,\n        addressToBytes32(packetHead.sender),\n        packetHead.dstEid,\n        addressToBytes32(packetHead.receiver)\n      ]\n    )\n  );\n}\n\n// src/codec/packet-serializer.ts\nvar PacketSerializer = class {\n  static serialize(packet) {\n    return PacketV1Codec.encode(packet);\n  }\n  static deserialize(bytesLike) {\n    let codec;\n    if (bytesLike instanceof Uint8Array) {\n      codec = PacketV1Codec.fromBytes(bytesLike);\n    } else {\n      codec = PacketV1Codec.from(bytesLike);\n    }\n    return codec.toPacket();\n  }\n};\n\nObject.defineProperty(exports, \"keccak256\", ({\n  enumerable: true,\n  get: function () { return keccak256.keccak256; }\n}));\nexports.ExecutorOptionType = ExecutorOptionType;\nexports.OptionType = OptionType;\nexports.Options = Options;\nexports.PacketSerializer = PacketSerializer;\nexports.PacketV1Codec = PacketV1Codec;\nexports.VerifierOptionType = VerifierOptionType;\nexports.WorkerId = WorkerId;\nexports.addressToBytes32 = addressToBytes32;\nexports.bytes32ToEthAddress = bytes32ToEthAddress;\nexports.calculateGuid = calculateGuid;\nexports.hexZeroPadTo32 = hexZeroPadTo32;\nexports.isSolanaAddress = isSolanaAddress;\nexports.optionsType1 = optionsType1;\nexports.optionsType2 = optionsType2;\nexports.packetToMessageOrigin = packetToMessageOrigin;\nexports.parseError = parseError;\nexports.parsePrecrimeConfig = parsePrecrimeConfig;\nexports.trim0x = trim0x;\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=index.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxheWVyemVyb2xhYnMvbHotdjItdXRpbGl0aWVzL2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDOUMsWUFBWSxtQkFBTyxDQUFDLHdGQUFzQjtBQUMxQyxjQUFjLG1CQUFPLENBQUMsOEVBQWlCO0FBQ3ZDLFVBQVUsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMsZ0dBQTBCO0FBQ2xELGVBQWUsbUJBQU8sQ0FBQyw4RkFBeUI7QUFDaEQsZ0JBQWdCLG1CQUFPLENBQUMsc0ZBQWdCO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLGdHQUEwQjs7QUFFbEQsK0JBQStCLGlDQUFpQzs7QUFFaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsTUFBTTtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQSx3Q0FBd0MsdUNBQXVDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3QkFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaURBQWlEO0FBQ3pGLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdDQUFnQyw2QkFBNkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTRDO0FBQzVDO0FBQ0EscUJBQXFCO0FBQ3JCLENBQUMsRUFBQztBQUNGLDBCQUEwQjtBQUMxQixrQkFBa0I7QUFDbEIsZUFBZTtBQUNmLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQix3QkFBd0I7QUFDeEIsMkJBQTJCO0FBQzNCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsNkJBQTZCO0FBQzdCLGtCQUFrQjtBQUNsQiwyQkFBMkI7QUFDM0IsY0FBYztBQUNkO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbGF5ZXJ6ZXJvbGFicy9vZnQtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9AbGF5ZXJ6ZXJvbGFicy9sei12Mi11dGlsaXRpZXMvZGlzdC9pbmRleC5janM/NzIxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBhZGRyZXNzID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYWRkcmVzcycpO1xudmFyIGJ5dGVzID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYnl0ZXMnKTtcbnZhciB3ZWIzX2pzID0gcmVxdWlyZSgnQHNvbGFuYS93ZWIzLmpzJyk7XG52YXIgYWJpID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYWJpJyk7XG52YXIgYmlnbnVtYmVyID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyJyk7XG52YXIgc29saWRpdHkgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9zb2xpZGl0eScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ3RpbnktaW52YXJpYW50Jyk7XG52YXIga2VjY2FrMjU2ID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cblxudmFyIGludmFyaWFudF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHQoaW52YXJpYW50KTtcblxuLy8gc3JjL3V0aWxzL2hleC50c1xuZnVuY3Rpb24gaGV4WmVyb1BhZFRvMzIoYWRkcikge1xuICByZXR1cm4gYnl0ZXMuaGV4WmVyb1BhZChhZGRyLCAzMik7XG59XG5mdW5jdGlvbiBieXRlczMyVG9FdGhBZGRyZXNzKGJ5dGVzMzIpIHtcbiAgaWYgKGJ5dGVzMzIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgYnl0ZXMzMiA9IGJ5dGVzLmhleGxpZnkoYnl0ZXMzMik7XG4gIH1cbiAgcmV0dXJuIGFkZHJlc3MuZ2V0QWRkcmVzcyhieXRlczMyLnNsaWNlKC00MCkpO1xufVxuZnVuY3Rpb24gdHJpbTB4KHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL14weC8sIFwiXCIpO1xufVxuZnVuY3Rpb24gYWRkcmVzc1RvQnl0ZXMzMihhZGRyZXNzKSB7XG4gIGlmIChpc1NvbGFuYUFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICByZXR1cm4gbmV3IHdlYjNfanMuUHVibGljS2V5KGFkZHJlc3MpLnRvQnl0ZXMoKTtcbiAgfSBlbHNlIGlmIChhZGRyZXNzLnN0YXJ0c1dpdGgoXCIweFwiKSAmJiBhZGRyZXNzLmxlbmd0aCA8PSA2Nikge1xuICAgIHJldHVybiBieXRlcy5hcnJheWlmeShoZXhaZXJvUGFkVG8zMihhZGRyZXNzKSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhZGRyZXNzXCIpO1xufVxudmFyIHNvbGFuYUFkZHJlc3NSZWdleCA9IC9eKFsxLTlBLUhKLU5QLVphLWttLXpdezMyLDQ0fSkkLztcbmZ1bmN0aW9uIGlzU29sYW5hQWRkcmVzcyhhZGRyZXNzKSB7XG4gIHJldHVybiBzb2xhbmFBZGRyZXNzUmVnZXgudGVzdChhZGRyZXNzKTtcbn1cblxuLy8gc3JjL3V0aWxzL3ByZWNyaW1lLnRzXG52YXIgQ09ORklHX1ZFUlNJT05fT0ZGU0VUID0gMDtcbnZhciBNQVhfQkFUQ0hfU0laRV9PRkZTRVQgPSAyO1xudmFyIE5VTUJFUl9PRl9QRUVSU19PRkZTRVQgPSAxMDtcbnZhciBQRUVSU19PRkZTRVQgPSAxMjtcbmZ1bmN0aW9uIHBhcnNlUHJlY3JpbWVDb25maWcocHJlY3JpbWVDb25maWcpIHtcbiAgY29uc3QgZGF0YSA9IHRyaW0weChwcmVjcmltZUNvbmZpZyk7XG4gIGNvbnN0IHZlcnNpb24gPSBwYXJzZUludChkYXRhLnNsaWNlKDAsIDQpLCAxNik7XG4gIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgcmV0dXJuIHBhcnNlUHJlY3JpbWVDb25maWdWMShwcmVjcmltZUNvbmZpZyk7XG4gIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gMikge1xuICAgIHJldHVybiBwYXJzZVByZWNyaW1lQ29uZmlnVjIocHJlY3JpbWVDb25maWcpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcHJlY3JpbWUgY29uZmlnIHZlcnNpb246ICR7dmVyc2lvbn1gKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHJlY3JpbWVDb25maWdWMShwcmVjcmltZUNvbmZpZykge1xuICBjb25zdCBkYXRhID0gdHJpbTB4KHByZWNyaW1lQ29uZmlnKTtcbiAgY29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KGRhdGEuc2xpY2UoMCwgNCksIDE2KTtcbiAgY29uc3QgbWF4QmF0Y2hTaXplID0gcGFyc2VJbnQoZGF0YS5zbGljZSg0LCAyMCksIDE2KTtcbiAgY29uc3QgcmVtb3RlQ2hhaW5zTGVuZ3RoID0gcGFyc2VJbnQoZGF0YS5zbGljZSgyMCwgODQpLCAxNik7XG4gIGNvbnN0IHJlbW90ZUNoYWluc0J5dGVzID0gZGF0YS5zbGljZSg4NCwgODQgKyByZW1vdGVDaGFpbnNMZW5ndGggKiA2NCk7XG4gIGNvbnN0IHJlbW90ZUFkZHJlc3Nlc0J5dGVzID0gZGF0YS5zbGljZShcbiAgICA4NCArIHJlbW90ZUNoYWluc0xlbmd0aCAqIDY0LFxuICAgIDg0ICsgcmVtb3RlQ2hhaW5zTGVuZ3RoICogNjQgKyByZW1vdGVDaGFpbnNMZW5ndGggKiA2NFxuICApO1xuICBjb25zdCByZW1vdGVDaGFpbnNCeXRlc0FycmF5ID0gW107XG4gIGNvbnN0IHJlbW90ZUFkZHJlc3Nlc0J5dGVzQXJyYXkgPSBbXTtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IDY0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW90ZUNoYWluc0xlbmd0aDsgaSsrKSB7XG4gICAgcmVtb3RlQ2hhaW5zQnl0ZXNBcnJheS5wdXNoKHBhcnNlSW50KHJlbW90ZUNoYWluc0J5dGVzLnNsaWNlKHN0YXJ0LCBlbmQpLCAxNikpO1xuICAgIHJlbW90ZUFkZHJlc3Nlc0J5dGVzQXJyYXkucHVzaChgMHgke3JlbW90ZUFkZHJlc3Nlc0J5dGVzLnNsaWNlKHN0YXJ0LCBlbmQpfWApO1xuICAgIHN0YXJ0ICs9IDY0O1xuICAgIGVuZCArPSA2NDtcbiAgfVxuICByZXR1cm4geyB2ZXJzaW9uLCBtYXhCYXRjaFNpemUsIHJlbW90ZUVpZHM6IHJlbW90ZUNoYWluc0J5dGVzQXJyYXksIHJlbW90ZUFkZHJlc3NlczogcmVtb3RlQWRkcmVzc2VzQnl0ZXNBcnJheSB9O1xufVxuZnVuY3Rpb24gcGFyc2VQcmVjcmltZUNvbmZpZ1YyKHByZWNyaW1lQ29uZmlnKSB7XG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHRyaW0weChwcmVjcmltZUNvbmZpZyksIFwiaGV4XCIpO1xuICBjb25zdCB2ZXJzaW9uID0gYnVmZmVyLnJlYWRVSW50MTZCRShDT05GSUdfVkVSU0lPTl9PRkZTRVQpO1xuICBjb25zdCBtYXhCYXRjaFNpemUgPSBidWZmZXIucmVhZEJpZ1VpbnQ2NEJFKE1BWF9CQVRDSF9TSVpFX09GRlNFVCk7XG4gIGNvbnN0IHBlZXJzID0gbmV3IEFycmF5KCk7XG4gIGlmIChidWZmZXIubGVuZ3RoID4gTlVNQkVSX09GX1BFRVJTX09GRlNFVCkge1xuICAgIGNvbnN0IG51bU9mUGVlcnMgPSBidWZmZXIucmVhZFVJbnQxNkJFKE5VTUJFUl9PRl9QRUVSU19PRkZTRVQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtT2ZQZWVyczsgaSsrKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBQRUVSU19PRkZTRVQgKyBpICogKDQgKyAyICogMzIpO1xuICAgICAgY29uc3QgZWlkID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICAgICAgY29uc3QgcHJlQ3JpbWVBZGRyZXNzID0gXCIweFwiICsgYnVmZmVyLnNsaWNlKG9mZnNldCArIDQsIG9mZnNldCArIDQgKyAzMikudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgICBjb25zdCBvYXBwQWRkcmVzcyA9IFwiMHhcIiArIGJ1ZmZlci5zbGljZShvZmZzZXQgKyA0ICsgMzIsIG9mZnNldCArIDQgKyAzMiArIDMyKS50b1N0cmluZyhcImhleFwiKTtcbiAgICAgIHBlZXJzLnB1c2goe1xuICAgICAgICBlaWQsXG4gICAgICAgIHByZUNyaW1lQWRkcmVzcyxcbiAgICAgICAgb2FwcEFkZHJlc3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHZlcnNpb24sXG4gICAgbWF4QmF0Y2hTaXplLFxuICAgIHBlZXJzXG4gIH07XG59XG52YXIgcGFyc2VFcnJvciA9IChlcnJvckRhdGEsIGludGYpID0+IHtcbiAgY29uc3QgYnVpbGRJbkVycm9yID0gcGFyc2VCdWlsZEluRXJyb3IoZXJyb3JEYXRhKTtcbiAgaWYgKGJ1aWxkSW5FcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGJ1aWxkSW5FcnJvcjtcbiAgfVxuICBpZiAoaW50Zikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gaW50Zi5wYXJzZUVycm9yKGVycm9yRGF0YSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBwYXJzZUJ1aWxkSW5FcnJvcihlcnJvckRhdGEpIHtcbiAgaWYgKGVycm9yRGF0YS5zdGFydHNXaXRoKFwiMHgwOGMzNzlhMFwiKSkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBgMHgke2Vycm9yRGF0YS5zdWJzdHJpbmcoMTApfWA7XG4gICAgY29uc3QgcmVhc29uID0gYWJpLmRlZmF1bHRBYmlDb2Rlci5kZWNvZGUoW1wic3RyaW5nXCJdLCBjb250ZW50KTtcbiAgICByZXR1cm4gcmVhc29uWzBdO1xuICB9XG4gIGlmIChlcnJvckRhdGEuc3RhcnRzV2l0aChcIjB4NGU0ODdiNzFcIikpIHtcbiAgICBjb25zdCBjb250ZW50ID0gYDB4JHtlcnJvckRhdGEuc3Vic3RyaW5nKDEwKX1gO1xuICAgIGNvbnN0IGNvZGUgPSBhYmkuZGVmYXVsdEFiaUNvZGVyLmRlY29kZShbXCJ1aW50XCJdLCBjb250ZW50KTtcbiAgICByZXR1cm4gY29kZVswXTtcbiAgfVxuICBpZiAoZXJyb3JEYXRhID09PSBcIjB4XCIpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxufVxudmFyIE9wdGlvblR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChPcHRpb25UeXBlMikgPT4ge1xuICBPcHRpb25UeXBlMltPcHRpb25UeXBlMltcIlRZUEVfMVwiXSA9IDFdID0gXCJUWVBFXzFcIjtcbiAgT3B0aW9uVHlwZTJbT3B0aW9uVHlwZTJbXCJUWVBFXzJcIl0gPSAyXSA9IFwiVFlQRV8yXCI7XG4gIE9wdGlvblR5cGUyW09wdGlvblR5cGUyW1wiVFlQRV8zXCJdID0gM10gPSBcIlRZUEVfM1wiO1xuICByZXR1cm4gT3B0aW9uVHlwZTI7XG59KShPcHRpb25UeXBlIHx8IHt9KTtcbnZhciBNQVhfVUlOVF8xMjggPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuZnVuY3Rpb24gb3B0aW9uc1R5cGUxKF9leHRyYUdhcykge1xuICBjb25zdCBleHRyYUdhcyA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShfZXh0cmFHYXMpO1xuICBpbnZhcmlhbnRfX2RlZmF1bHQuZGVmYXVsdChleHRyYUdhcy5sdGUoTUFYX1VJTlRfMTI4KSwgXCJleHRyYUdhcyBzaG91bGQgYmUgbGVzcyB0aGFuIE1BWF9VSU5UXzEyOFwiKTtcbiAgcmV0dXJuIHNvbGlkaXR5LnBhY2soW1widWludDE2XCIsIFwidWludDI1NlwiXSwgWzEgLyogVFlQRV8xICovLCBleHRyYUdhc10pO1xufVxuZnVuY3Rpb24gb3B0aW9uc1R5cGUyKF9leHRyYUdhcywgX2RzdE5hdGl2ZUFtdCwgX2RzdE5hdGl2ZUFkZHJlc3MpIHtcbiAgY29uc3QgZXh0cmFHYXMgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oX2V4dHJhR2FzKTtcbiAgaW52YXJpYW50X19kZWZhdWx0LmRlZmF1bHQoZXh0cmFHYXMubHRlKE1BWF9VSU5UXzEyOCksIFwiZXh0cmFHYXMgc2hvdWxkIGJlIGxlc3MgdGhhbiBNQVhfVUlOVF8xMjhcIik7XG4gIGNvbnN0IGRzdE5hdGl2ZUFtdCA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShfZHN0TmF0aXZlQW10KTtcbiAgaW52YXJpYW50X19kZWZhdWx0LmRlZmF1bHQoZHN0TmF0aXZlQW10Lmx0ZShNQVhfVUlOVF8xMjgpLCBcImRzdE5hdGl2ZUFtdCBzaG91bGQgYmUgbGVzcyB0aGFuIE1BWF9VSU5UXzEyOFwiKTtcbiAgcmV0dXJuIHNvbGlkaXR5LnBhY2soXG4gICAgW1widWludDE2XCIsIFwidWludDI1NlwiLCBcInVpbnQyNTZcIiwgXCJieXRlc1wiXSxcbiAgICBbMiAvKiBUWVBFXzIgKi8sIGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShleHRyYUdhcyksIGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShkc3ROYXRpdmVBbXQpLCBfZHN0TmF0aXZlQWRkcmVzc11cbiAgKTtcbn1cbnZhciBXb3JrZXJJZCA9IC8qIEBfX1BVUkVfXyAqLyAoKFdvcmtlcklkMikgPT4ge1xuICBXb3JrZXJJZDJbV29ya2VySWQyW1wiRVhFQ1VUT1JcIl0gPSAxXSA9IFwiRVhFQ1VUT1JcIjtcbiAgV29ya2VySWQyW1dvcmtlcklkMltcIlZFUklGSUVSXCJdID0gMl0gPSBcIlZFUklGSUVSXCI7XG4gIFdvcmtlcklkMltXb3JrZXJJZDJbXCJUUkVBU1VSWVwiXSA9IDI1NV0gPSBcIlRSRUFTVVJZXCI7XG4gIHJldHVybiBXb3JrZXJJZDI7XG59KShXb3JrZXJJZCB8fCB7fSk7XG52YXIgRXhlY3V0b3JPcHRpb25UeXBlID0gLyogQF9fUFVSRV9fICovICgoRXhlY3V0b3JPcHRpb25UeXBlMikgPT4ge1xuICBFeGVjdXRvck9wdGlvblR5cGUyW0V4ZWN1dG9yT3B0aW9uVHlwZTJbXCJMWl9SRUNFSVZFXCJdID0gMV0gPSBcIkxaX1JFQ0VJVkVcIjtcbiAgRXhlY3V0b3JPcHRpb25UeXBlMltFeGVjdXRvck9wdGlvblR5cGUyW1wiTkFUSVZFX0RST1BcIl0gPSAyXSA9IFwiTkFUSVZFX0RST1BcIjtcbiAgRXhlY3V0b3JPcHRpb25UeXBlMltFeGVjdXRvck9wdGlvblR5cGUyW1wiQ09NUE9TRVwiXSA9IDNdID0gXCJDT01QT1NFXCI7XG4gIEV4ZWN1dG9yT3B0aW9uVHlwZTJbRXhlY3V0b3JPcHRpb25UeXBlMltcIk9SREVSRURcIl0gPSA0XSA9IFwiT1JERVJFRFwiO1xuICByZXR1cm4gRXhlY3V0b3JPcHRpb25UeXBlMjtcbn0pKEV4ZWN1dG9yT3B0aW9uVHlwZSB8fCB7fSk7XG52YXIgVmVyaWZpZXJPcHRpb25UeXBlID0gLyogQF9fUFVSRV9fICovICgoVmVyaWZpZXJPcHRpb25UeXBlMikgPT4ge1xuICBWZXJpZmllck9wdGlvblR5cGUyW1ZlcmlmaWVyT3B0aW9uVHlwZTJbXCJQUkVDUklNRVwiXSA9IDFdID0gXCJQUkVDUklNRVwiO1xuICByZXR1cm4gVmVyaWZpZXJPcHRpb25UeXBlMjtcbn0pKFZlcmlmaWVyT3B0aW9uVHlwZSB8fCB7fSk7XG52YXIgT3B0aW9ucyA9IGNsYXNzIF9PcHRpb25zIHtcbiAgd29ya2VyT3B0aW9ucyA9IFtdO1xuICAvLyBkaXNzdWFkZSBwdWJsaWMgaW5zdGFudGlhdGlvblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG9wdGlvbnMgaW5zdGFuY2UuXG4gICAqL1xuICBzdGF0aWMgbmV3T3B0aW9ucygpIHtcbiAgICByZXR1cm4gbmV3IF9PcHRpb25zKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBvcHRpb25zIGluc3RhbmNlIGZyb20gYSBoZXggc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uc0hleCBUaGUgaGV4IHN0cmluZyB0byBkZWNvZGUuXG4gICAqL1xuICBzdGF0aWMgZnJvbU9wdGlvbnMob3B0aW9uc0hleCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBuZXcgX09wdGlvbnMoKTtcbiAgICBjb25zdCBvcHRpb25zQnl0ZXMgPSBieXRlcy5hcnJheWlmeShvcHRpb25zSGV4KTtcbiAgICBjb25zdCBvcHRpb25zVHlwZSA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShvcHRpb25zQnl0ZXMuc2xpY2UoMCwgMikpLnRvTnVtYmVyKCk7XG4gICAgaWYgKG9wdGlvbnNUeXBlID09PSAzIC8qIFRZUEVfMyAqLykge1xuICAgICAgbGV0IGN1cnNvciA9IDI7XG4gICAgICB3aGlsZSAoY3Vyc29yIDwgb3B0aW9uc0J5dGVzLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgd29ya2VySWQgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20ob3B0aW9uc0J5dGVzLnNsaWNlKGN1cnNvciwgY3Vyc29yICsgMSkpLnRvTnVtYmVyKCk7XG4gICAgICAgIGN1cnNvciArPSAxO1xuICAgICAgICBjb25zdCBzaXplID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKG9wdGlvbnNCeXRlcy5zbGljZShjdXJzb3IsIGN1cnNvciArIDIpKS50b051bWJlcigpO1xuICAgICAgICBjdXJzb3IgKz0gMjtcbiAgICAgICAgaWYgKHdvcmtlcklkID09PSAxIC8qIEVYRUNVVE9SICovKSB7XG4gICAgICAgICAgY29uc3Qgb3B0aW9uVHlwZSA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShvcHRpb25zQnl0ZXMuc2xpY2UoY3Vyc29yLCBjdXJzb3IgKyAxKSkudG9OdW1iZXIoKTtcbiAgICAgICAgICBjdXJzb3IgKz0gMTtcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSBvcHRpb25zQnl0ZXMuc2xpY2UoY3Vyc29yLCBjdXJzb3IgKyBzaXplIC0gMSk7XG4gICAgICAgICAgY3Vyc29yICs9IHNpemUgLSAxO1xuICAgICAgICAgIG9wdGlvbnMuYWRkT3B0aW9uKHdvcmtlcklkLCB7IHR5cGU6IG9wdGlvblR5cGUsIHBhcmFtczogYnl0ZXMuaGV4bGlmeShwYXJhbXMpIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHdvcmtlcklkID09PSAyIC8qIFZFUklGSUVSICovKSB7XG4gICAgICAgICAgY29uc3QgdmVyaWZpZXJJZHggPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20ob3B0aW9uc0J5dGVzLnNsaWNlKGN1cnNvciwgY3Vyc29yICsgMSkpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgY3Vyc29yICs9IDE7XG4gICAgICAgICAgY29uc3Qgb3B0aW9uVHlwZSA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShvcHRpb25zQnl0ZXMuc2xpY2UoY3Vyc29yLCBjdXJzb3IgKyAxKSkudG9OdW1iZXIoKTtcbiAgICAgICAgICBjdXJzb3IgKz0gMTtcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSBvcHRpb25zQnl0ZXMuc2xpY2UoY3Vyc29yLCBjdXJzb3IgKyBzaXplIC0gMik7XG4gICAgICAgICAgY3Vyc29yICs9IHNpemUgLSAyO1xuICAgICAgICAgIG9wdGlvbnMuYWRkT3B0aW9uKHdvcmtlcklkLCB7XG4gICAgICAgICAgICB0eXBlOiBvcHRpb25UeXBlLFxuICAgICAgICAgICAgaW5kZXg6IHZlcmlmaWVySWR4LFxuICAgICAgICAgICAgcGFyYW1zOiBieXRlcy5oZXhsaWZ5KHBhcmFtcylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9uc1R5cGUgPT09IDIgLyogVFlQRV8yICovKSB7XG4gICAgICBjb25zdCBleHRyYUdhcyA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShvcHRpb25zQnl0ZXMuc2xpY2UoMiwgMzQpKS50b0JpZ0ludCgpO1xuICAgICAgY29uc3QgZHN0TmF0aXZlQW10ID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKG9wdGlvbnNCeXRlcy5zbGljZSgzNCwgNjYpKS50b0JpZ0ludCgpO1xuICAgICAgY29uc3QgZHN0TmF0aXZlQWRkcmVzcyA9IGJ5dGVzLmhleGxpZnkob3B0aW9uc0J5dGVzLnNsaWNlKDY2LCBvcHRpb25zQnl0ZXMuYnl0ZUxlbmd0aCkpO1xuICAgICAgb3B0aW9ucy5hZGRFeGVjdXRvckx6UmVjZWl2ZU9wdGlvbihleHRyYUdhcykuYWRkRXhlY3V0b3JOYXRpdmVEcm9wT3B0aW9uKGRzdE5hdGl2ZUFtdCwgZHN0TmF0aXZlQWRkcmVzcyk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zVHlwZSA9PT0gMSAvKiBUWVBFXzEgKi8pIHtcbiAgICAgIGNvbnN0IGV4dHJhR2FzID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKG9wdGlvbnNCeXRlcy5zbGljZSgyLCAzNCkpLnRvQmlnSW50KCk7XG4gICAgICBvcHRpb25zLmFkZEV4ZWN1dG9yTHpSZWNlaXZlT3B0aW9uKGV4dHJhR2FzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBFeGVjdXRvck9wdGlvblR5cGUuTFpfUkVDRUlWRSBvcHRpb24uXG4gICAqIEBwYXJhbSB7R2FzTGltaXR9IGdhc0xpbWl0XG4gICAqIEBwYXJhbSB7TmF0aXZlRHJvcH0gbmF0aXZlRHJvcFxuICAgKi9cbiAgYWRkRXhlY3V0b3JMelJlY2VpdmVPcHRpb24oZ2FzTGltaXQsIG5hdGl2ZURyb3AgPSAwKSB7XG4gICAgY29uc3QgZ2FzTGltaXRCTiA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShnYXNMaW1pdCk7XG4gICAgaW52YXJpYW50X19kZWZhdWx0LmRlZmF1bHQoZ2FzTGltaXRCTi5sdGUoTUFYX1VJTlRfMTI4KSwgXCJnYXNMaW1pdCBzaG91bGRuJ3QgYmUgZ3JlYXRlciB0aGFuIE1BWF9VSU5UXzEyOFwiKTtcbiAgICBjb25zdCBuYXRpdmVEcm9wQk4gPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20obmF0aXZlRHJvcCk7XG4gICAgaW52YXJpYW50X19kZWZhdWx0LmRlZmF1bHQobmF0aXZlRHJvcEJOLmx0ZShNQVhfVUlOVF8xMjgpLCBcInZhbHVlIHNob3VsZG4ndCBiZSBncmVhdGVyIHRoYW4gTUFYX1VJTlRfMTI4XCIpO1xuICAgIHRoaXMuYWRkT3B0aW9uKDEgLyogRVhFQ1VUT1IgKi8sIHtcbiAgICAgIHR5cGU6IDEgLyogTFpfUkVDRUlWRSAqLyxcbiAgICAgIHBhcmFtczogbmF0aXZlRHJvcEJOLmVxKDApID8gc29saWRpdHkucGFjayhbXCJ1aW50MTI4XCJdLCBbZ2FzTGltaXRCTl0pIDogc29saWRpdHkucGFjayhbXCJ1aW50MTI4XCIsIFwidWludDEyOFwiXSwgW2dhc0xpbWl0Qk4sIG5hdGl2ZURyb3BCTl0pXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBFeGVjdXRvck9wdGlvblR5cGUuTkFUSVZFX0RST1Agb3B0aW9uLlxuICAgKiBAcGFyYW0ge05hdGl2ZURyb3B9IG5hdGl2ZURyb3BcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlY2VpdmVyXG4gICAqL1xuICBhZGRFeGVjdXRvck5hdGl2ZURyb3BPcHRpb24obmF0aXZlRHJvcCwgcmVjZWl2ZXIpIHtcbiAgICBjb25zdCBhbW91bnRCTiA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShuYXRpdmVEcm9wKTtcbiAgICBpbnZhcmlhbnRfX2RlZmF1bHQuZGVmYXVsdChhbW91bnRCTi5sdGUoTUFYX1VJTlRfMTI4KSwgXCJuYXRpdmVEcm9wIHNob3VsZG4ndCBiZSBncmVhdGVyIHRoYW4gTUFYX1VJTlRfMTI4XCIpO1xuICAgIHRoaXMuYWRkT3B0aW9uKDEgLyogRVhFQ1VUT1IgKi8sIHtcbiAgICAgIHR5cGU6IDIgLyogTkFUSVZFX0RST1AgKi8sXG4gICAgICBwYXJhbXM6IHNvbGlkaXR5LnBhY2soW1widWludDEyOFwiLCBcImJ5dGVzMzJcIl0sIFthbW91bnRCTiwgaGV4WmVyb1BhZFRvMzIocmVjZWl2ZXIpXSlcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkIEV4ZWN1dG9yT3B0aW9uVHlwZS5DT01QT1NFIG9wdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7R2FzTGltaXR9IGdhc0xpbWl0XG4gICAqIEBwYXJhbSB7TmF0aXZlRHJvcH0gbmF0aXZlRHJvcFxuICAgKi9cbiAgYWRkRXhlY3V0b3JDb21wb3NlT3B0aW9uKGluZGV4LCBnYXNMaW1pdCwgbmF0aXZlRHJvcCA9IDApIHtcbiAgICBjb25zdCBnYXNMaW1pdEJOID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKGdhc0xpbWl0KTtcbiAgICBpbnZhcmlhbnRfX2RlZmF1bHQuZGVmYXVsdChnYXNMaW1pdEJOLmx0ZShNQVhfVUlOVF8xMjgpLCBcImdhc0xpbWl0IHNob3VsZG4ndCBiZSBncmVhdGVyIHRoYW4gTUFYX1VJTlRfMTI4XCIpO1xuICAgIGNvbnN0IG5hdGl2ZURyb3BCTiA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShuYXRpdmVEcm9wKTtcbiAgICBpbnZhcmlhbnRfX2RlZmF1bHQuZGVmYXVsdChuYXRpdmVEcm9wQk4ubHRlKE1BWF9VSU5UXzEyOCksIFwibmF0aXZlRHJvcCBzaG91bGRuJ3QgYmUgZ3JlYXRlciB0aGFuIE1BWF9VSU5UXzEyOFwiKTtcbiAgICBjb25zdCBvcHRpb24gPSBuYXRpdmVEcm9wQk4uZ3QoMCkgPyB7XG4gICAgICB0eXBlOiAzIC8qIENPTVBPU0UgKi8sXG4gICAgICBwYXJhbXM6IHNvbGlkaXR5LnBhY2soW1widWludDE2XCIsIFwidWludDEyOFwiLCBcInVpbnQxMjhcIl0sIFtpbmRleCwgZ2FzTGltaXRCTiwgbmF0aXZlRHJvcEJOXSlcbiAgICB9IDoge1xuICAgICAgdHlwZTogMyAvKiBDT01QT1NFICovLFxuICAgICAgcGFyYW1zOiBzb2xpZGl0eS5wYWNrKFtcInVpbnQxNlwiLCBcInVpbnQxMjhcIl0sIFtpbmRleCwgZ2FzTGltaXRCTl0pXG4gICAgfTtcbiAgICB0aGlzLmFkZE9wdGlvbigxIC8qIEVYRUNVVE9SICovLCBvcHRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgRXhlY3V0b3JPcHRpb25UeXBlLk9SREVSRUQgb3B0aW9uLlxuICAgKi9cbiAgYWRkRXhlY3V0b3JPcmRlcmVkRXhlY3V0aW9uT3B0aW9uKCkge1xuICAgIHRoaXMuYWRkT3B0aW9uKDEgLyogRVhFQ1VUT1IgKi8sIHtcbiAgICAgIHR5cGU6IDQgLyogT1JERVJFRCAqLyxcbiAgICAgIHBhcmFtczogXCIweFwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBWZXJpZmllck9wdGlvblR5cGUuUFJFQ1JJTUUgb3B0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmVyaWZpZXJJZHhcbiAgICovXG4gIGFkZFZlcmlmaWVyUHJlY3JpbWVPcHRpb24odmVyaWZpZXJJZHgpIHtcbiAgICB0aGlzLmFkZE9wdGlvbigyIC8qIFZFUklGSUVSICovLCB7XG4gICAgICB0eXBlOiAxIC8qIFBSRUNSSU1FICovLFxuICAgICAgaW5kZXg6IHZlcmlmaWVySWR4LFxuICAgICAgcGFyYW1zOiBcIjB4XCJcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIE9wdGlvbnMgdG8gaGV4IHN0cmluZy5cbiAgICovXG4gIHRvSGV4KCkge1xuICAgIGxldCBoZXggPSBzb2xpZGl0eS5wYWNrKFtcInVpbnQxNlwiXSwgWzMgLyogVFlQRV8zICovXSk7XG4gICAgdGhpcy53b3JrZXJPcHRpb25zLmZvckVhY2goKHcpID0+IHtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHcub3B0aW9ucykge1xuICAgICAgICBpZiAody53b3JrZXJJZCA9PT0gMSAvKiBFWEVDVVRPUiAqLykge1xuICAgICAgICAgIGhleCArPSB0cmltMHgoXG4gICAgICAgICAgICBzb2xpZGl0eS5wYWNrKFxuICAgICAgICAgICAgICBbXCJ1aW50OFwiLCBcInVpbnQxNlwiLCBcInVpbnQ4XCIsIFwiYnl0ZXNcIl0sXG4gICAgICAgICAgICAgIFt3LndvcmtlcklkLCB0cmltMHgob3B0aW9uLnBhcmFtcykubGVuZ3RoIC8gMiArIDEsIG9wdGlvbi50eXBlLCBvcHRpb24ucGFyYW1zXVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAody53b3JrZXJJZCA9PT0gMiAvKiBWRVJJRklFUiAqLykge1xuICAgICAgICAgIGNvbnN0IHZlcmlmaWVyT3B0aW9uID0gb3B0aW9uO1xuICAgICAgICAgIGhleCArPSB0cmltMHgoXG4gICAgICAgICAgICBzb2xpZGl0eS5wYWNrKFxuICAgICAgICAgICAgICBbXCJ1aW50OFwiLCBcInVpbnQxNlwiLCBcInVpbnQ4XCIsIFwidWludDhcIiwgXCJieXRlc1wiXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHcud29ya2VySWQsXG4gICAgICAgICAgICAgICAgdHJpbTB4KG9wdGlvbi5wYXJhbXMpLmxlbmd0aCAvIDIgKyAyLFxuICAgICAgICAgICAgICAgIHZlcmlmaWVyT3B0aW9uLmluZGV4LFxuICAgICAgICAgICAgICAgIHZlcmlmaWVyT3B0aW9uLnR5cGUsXG4gICAgICAgICAgICAgICAgdmVyaWZpZXJPcHRpb24ucGFyYW1zXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGhleDtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIE9wdGlvbnMgdG8gVWludDhBcnJheS5cbiAgICovXG4gIHRvQnl0ZXMoKSB7XG4gICAgcmV0dXJuIGJ5dGVzLmFycmF5aWZ5KHRoaXMudG9IZXgoKSk7XG4gIH1cbiAgYWRkT3B0aW9uKHdvcmtlcklkLCBvcHRpb24pIHtcbiAgICBjb25zdCB3b3JrZXIgPSB0aGlzLndvcmtlck9wdGlvbnMuZmluZCgodykgPT4gdy53b3JrZXJJZCA9PT0gd29ya2VySWQpO1xuICAgIGlmICh3b3JrZXIpIHtcbiAgICAgIHdvcmtlci5vcHRpb25zLnB1c2gob3B0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3JrZXJPcHRpb25zLnB1c2goeyB3b3JrZXJJZCwgb3B0aW9uczogW29wdGlvbl0gfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZWNvZGUgRXhlY3V0b3JPcHRpb25UeXBlLkxaX1JFQ0VJVkUgb3B0aW9uLiAgUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIG9wdGlvbiBpcyBub3QgcHJlc2VudC5cbiAgICovXG4gIGRlY29kZUV4ZWN1dG9yTHpSZWNlaXZlT3B0aW9uKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmZpbmRPcHRpb25zKDEgLyogRVhFQ1VUT1IgKi8sIDEgLyogTFpfUkVDRUlWRSAqLyk7XG4gICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB0b3RhbEdhcyA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbSgwKS50b0JpZ0ludCgpO1xuICAgIGxldCB0b3RhbFZhbHVlID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKDApLnRvQmlnSW50KCk7XG4gICAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20odHJpbTB4KG9wdGlvbi5wYXJhbXMpLCBcImhleFwiKTtcbiAgICAgIGNvbnN0IGdhcyA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShidWZmZXIuc3ViYXJyYXkoMCwgMTYpKS50b0JpZ0ludCgpO1xuICAgICAgY29uc3QgdmFsdWUgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oYnVmZmVyLmxlbmd0aCA9PT0gMTYgPyAwIDogYnVmZmVyLnN1YmFycmF5KDE2LCAzMikpLnRvQmlnSW50KCk7XG4gICAgICB0b3RhbEdhcyA9IHRvdGFsR2FzICsgZ2FzO1xuICAgICAgdG90YWxWYWx1ZSA9IHRvdGFsVmFsdWUgKyB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZ2FzOiB0b3RhbEdhcywgdmFsdWU6IHRvdGFsVmFsdWUgfTtcbiAgfVxuICAvKipcbiAgICogRGVjb2RlIEV4ZWN1dG9yT3B0aW9uVHlwZS5OQVRJVkVfRFJPUCBvcHRpb25zLiAgUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIG9wdGlvbnMgaXMgbm90IHByZXNlbnQuXG4gICAqL1xuICBkZWNvZGVFeGVjdXRvck5hdGl2ZURyb3BPcHRpb24oKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZmluZE9wdGlvbnMoMSAvKiBFWEVDVVRPUiAqLywgMiAvKiBOQVRJVkVfRFJPUCAqLyk7XG4gICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdHMgPSBvcHRpb25zLnJlZHVjZSgoYWNjLCBjdXIpID0+IHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHRyaW0weChjdXIucGFyYW1zKSwgXCJoZXhcIik7XG4gICAgICBjb25zdCBhbW91bnQgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oYnVmZmVyLnN1YmFycmF5KDAsIDE2KSkudG9CaWdJbnQoKTtcbiAgICAgIGNvbnN0IHJlY2VpdmVyID0gYnl0ZXMuaGV4bGlmeShidWZmZXIuc3ViYXJyYXkoMTYsIDQ4KSk7XG4gICAgICBpZiAoYWNjW3JlY2VpdmVyXSkge1xuICAgICAgICBhY2NbcmVjZWl2ZXJdW1wiYW1vdW50XCJdID0gYWNjW3JlY2VpdmVyXS5hbW91bnQgKyBhbW91bnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY2NbcmVjZWl2ZXJdID0geyBhbW91bnQsIHJlY2VpdmVyIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZXN1bHRzKTtcbiAgfVxuICAvKipcbiAgICogRGVjb2RlIEV4ZWN1dG9yT3B0aW9uVHlwZS5DT01QT1NFIG9wdGlvbnMuICBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGUgb3B0aW9ucyBpcyBub3QgcHJlc2VudC5cbiAgICovXG4gIGRlY29kZUV4ZWN1dG9yQ29tcG9zZU9wdGlvbigpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5maW5kT3B0aW9ucygxIC8qIEVYRUNVVE9SICovLCAzIC8qIENPTVBPU0UgKi8pO1xuICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHRzID0gb3B0aW9ucy5yZWR1Y2UoXG4gICAgICAoYWNjLCBjdXIpID0+IHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20odHJpbTB4KGN1ci5wYXJhbXMpLCBcImhleFwiKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oYnVmZmVyLnN1YmFycmF5KDAsIDIpKS50b051bWJlcigpO1xuICAgICAgICBjb25zdCBnYXMgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oYnVmZmVyLnN1YmFycmF5KDIsIDE4KSkudG9CaWdJbnQoKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSAoYnVmZmVyLmxlbmd0aCA9PT0gMzQgPyBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oYnVmZmVyLnN1YmFycmF5KDE4LCAzNCkpIDogYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKDApKS50b0JpZ0ludCgpO1xuICAgICAgICBpZiAoYWNjW2luZGV4XSkge1xuICAgICAgICAgIGFjY1tpbmRleF1bXCJnYXNcIl0gPSBhY2NbaW5kZXhdLmdhcyArIGdhcztcbiAgICAgICAgICBhY2NbaW5kZXhdW1widmFsdWVcIl0gPSBhY2NbaW5kZXhdLnZhbHVlICsgdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWNjW2luZGV4XSA9IHsgaW5kZXgsIGdhcywgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZXN1bHRzKTtcbiAgfVxuICAvKipcbiAgICogRGVjb2RlIEV4ZWN1dG9yT3B0aW9uVHlwZS5PUkRFUkVEIG9wdGlvbnMuICBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGUgb3B0aW9ucyBpcyBub3QgcHJlc2VudC5cbiAgICovXG4gIGRlY29kZUV4ZWN1dG9yT3JkZXJlZEV4ZWN1dGlvbk9wdGlvbigpIHtcbiAgICBjb25zdCBvcHRpb24gPSB0aGlzLmZpbmRPcHRpb25zKDEgLyogRVhFQ1VUT1IgKi8sIDQgLyogT1JERVJFRCAqLyk7XG4gICAgcmV0dXJuIG9wdGlvbiAhPT0gdm9pZCAwO1xuICB9XG4gIGZpbmRPcHRpb25zKHdvcmtlcklkLCBvcHRpb25UeXBlKSB7XG4gICAgY29uc3Qgd29ya2VyID0gdGhpcy53b3JrZXJPcHRpb25zLmZpbmQoKHcpID0+IHcud29ya2VySWQgPT09IHdvcmtlcklkKTtcbiAgICBpZiAod29ya2VyKSB7XG4gICAgICBpZiAob3B0aW9uVHlwZSA9PT0gNCAvKiBPUkRFUkVEICovKSB7XG4gICAgICAgIHJldHVybiB3b3JrZXIub3B0aW9ucy5maW5kKChvKSA9PiBvLnR5cGUgPT09IG9wdGlvblR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdvcmtlci5vcHRpb25zLmZpbHRlcigobykgPT4gby50eXBlID09PSBvcHRpb25UeXBlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgVmVyaWZpZXJPcHRpb24gYnkgdmVyaWZpZXJJZHggYW5kIG9wdGlvblR5cGUuICBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGUgb3B0aW9uIGlzIG5vdCBwcmVzZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmVyaWZpZXJJZHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvblR5cGVcbiAgICovXG4gIGZpbmRWZXJpZmllck9wdGlvbih2ZXJpZmllcklkeCwgb3B0aW9uVHlwZSkge1xuICAgIGNvbnN0IHdvcmtlciA9IHRoaXMud29ya2VyT3B0aW9ucy5maW5kKCh3KSA9PiB3LndvcmtlcklkID09PSAyIC8qIFZFUklGSUVSICovKTtcbiAgICBpZiAod29ya2VyKSB7XG4gICAgICBjb25zdCBvcHQgPSB3b3JrZXIub3B0aW9ucy5maW5kKChvKSA9PiBvLnR5cGUgPT09IG9wdGlvblR5cGUgJiYgby5pbmRleCA9PT0gdmVyaWZpZXJJZHgpO1xuICAgICAgaWYgKG9wdCkge1xuICAgICAgICByZXR1cm4gb3B0O1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL21vZGVsL3BhY2tldC50c1xuZnVuY3Rpb24gcGFja2V0VG9NZXNzYWdlT3JpZ2luKHBhY2tldCkge1xuICByZXR1cm4ge1xuICAgIHNyY0VpZDogcGFja2V0LnNyY0VpZCxcbiAgICBzZW5kZXI6IHBhY2tldC5zZW5kZXIsXG4gICAgbm9uY2U6IHBhY2tldC5ub25jZVxuICB9O1xufVxudmFyIFBBQ0tFVF9WRVJTSU9OX09GRlNFVCA9IDA7XG52YXIgTk9OQ0VfT0ZGU0VUID0gMTtcbnZhciBTUkNfQ0hBSU5fT0ZGU0VUID0gOTtcbnZhciBTUkNfQUREUkVTU19PRkZTRVQgPSAxMztcbnZhciBEU1RfQ0hBSU5fT0ZGU0VUID0gNDU7XG52YXIgRFNUX0FERFJFU1NfT0ZGU0VUID0gNDk7XG52YXIgR1VJRF9PRkZTRVQgPSA4MTtcbnZhciBNRVNTQUdFX09GRlNFVCA9IDExMztcbnZhciBQYWNrZXRWMUNvZGVjID0gY2xhc3MgX1BhY2tldFYxQ29kZWMge1xuICBidWZmZXI7XG4gIHN0YXRpYyBmcm9tKHBheWxvYWRFbmNvZGVkKSB7XG4gICAgcmV0dXJuIG5ldyBfUGFja2V0VjFDb2RlYyhwYXlsb2FkRW5jb2RlZCk7XG4gIH1cbiAgc3RhdGljIGZyb21CeXRlcyhwYXlsb2FkKSB7XG4gICAgcmV0dXJuIG5ldyBfUGFja2V0VjFDb2RlYyhcIjB4XCIgKyBCdWZmZXIuZnJvbShwYXlsb2FkKS50b1N0cmluZyhcImhleFwiKSk7XG4gIH1cbiAgY29uc3RydWN0b3IocGF5bG9hZEVuY29kZWQpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHRyaW0weChwYXlsb2FkRW5jb2RlZCksIFwiaGV4XCIpO1xuICB9XG4gIC8qKlxuICAgKiBlbmNvZGUgcGFja2V0IHRvIGhleCBzdHJpbmdcbiAgICovXG4gIHN0YXRpYyBlbmNvZGUocGFja2V0KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRyaW0weChwYWNrZXQubWVzc2FnZSk7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKE1FU1NBR0VfT0ZGU0VUICsgbWVzc2FnZS5sZW5ndGggLyAyKTtcbiAgICBidWZmZXIud3JpdGVVSW50OChwYWNrZXQudmVyc2lvbiwgUEFDS0VUX1ZFUlNJT05fT0ZGU0VUKTtcbiAgICBidWZmZXIud3JpdGVCaWdVSW50NjRCRShCaWdJbnQocGFja2V0Lm5vbmNlKSwgTk9OQ0VfT0ZGU0VUKTtcbiAgICBidWZmZXIud3JpdGVVSW50MzJCRShwYWNrZXQuc3JjRWlkLCBTUkNfQ0hBSU5fT0ZGU0VUKTtcbiAgICBidWZmZXIud3JpdGUodHJpbTB4KGhleFplcm9QYWRUbzMyKHBhY2tldC5zZW5kZXIpKSwgU1JDX0FERFJFU1NfT0ZGU0VULCAzMiwgXCJoZXhcIik7XG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUocGFja2V0LmRzdEVpZCwgRFNUX0NIQUlOX09GRlNFVCk7XG4gICAgYnVmZmVyLndyaXRlKHRyaW0weChoZXhaZXJvUGFkVG8zMihwYWNrZXQucmVjZWl2ZXIpKSwgRFNUX0FERFJFU1NfT0ZGU0VULCAzMiwgXCJoZXhcIik7XG4gICAgYnVmZmVyLndyaXRlKHRyaW0weChwYWNrZXQuZ3VpZCksIEdVSURfT0ZGU0VULCAzMiwgXCJoZXhcIik7XG4gICAgYnVmZmVyLndyaXRlKG1lc3NhZ2UsIE1FU1NBR0VfT0ZGU0VULCBtZXNzYWdlLmxlbmd0aCAvIDIsIFwiaGV4XCIpO1xuICAgIHJldHVybiBcIjB4XCIgKyBidWZmZXIudG9TdHJpbmcoXCJoZXhcIik7XG4gIH1cbiAgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIucmVhZFVJbnQ4KFBBQ0tFVF9WRVJTSU9OX09GRlNFVCk7XG4gIH1cbiAgbm9uY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLnJlYWRCaWdVaW50NjRCRShOT05DRV9PRkZTRVQpLnRvU3RyaW5nKCk7XG4gIH1cbiAgc3JjRWlkKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5yZWFkVWludDMyQkUoU1JDX0NIQUlOX09GRlNFVCk7XG4gIH1cbiAgc2VuZGVyKCkge1xuICAgIHJldHVybiBcIjB4XCIgKyB0aGlzLmJ1ZmZlci5zbGljZShTUkNfQUREUkVTU19PRkZTRVQsIERTVF9DSEFJTl9PRkZTRVQpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICB9XG4gIHNlbmRlckFkZHJlc3NCMjAoKSB7XG4gICAgcmV0dXJuIGJ5dGVzMzJUb0V0aEFkZHJlc3ModGhpcy5zZW5kZXIoKSk7XG4gIH1cbiAgZHN0RWlkKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5yZWFkVWludDMyQkUoRFNUX0NIQUlOX09GRlNFVCk7XG4gIH1cbiAgcmVjZWl2ZXIoKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIHRoaXMuYnVmZmVyLnNsaWNlKERTVF9BRERSRVNTX09GRlNFVCwgR1VJRF9PRkZTRVQpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICB9XG4gIHJlY2VpdmVyQWRkcmVzc0IyMCgpIHtcbiAgICByZXR1cm4gYnl0ZXMzMlRvRXRoQWRkcmVzcyh0aGlzLnJlY2VpdmVyKCkpO1xuICB9XG4gIGd1aWQoKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIHRoaXMuYnVmZmVyLnNsaWNlKEdVSURfT0ZGU0VULCBNRVNTQUdFX09GRlNFVCkudG9TdHJpbmcoXCJoZXhcIik7XG4gIH1cbiAgbWVzc2FnZSgpIHtcbiAgICByZXR1cm4gXCIweFwiICsgdGhpcy5idWZmZXIuc2xpY2UoTUVTU0FHRV9PRkZTRVQpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICB9XG4gIHBheWxvYWRIYXNoKCkge1xuICAgIHJldHVybiBrZWNjYWsyNTYua2VjY2FrMjU2KHRoaXMucGF5bG9hZCgpKTtcbiAgfVxuICBwYXlsb2FkKCkge1xuICAgIHJldHVybiBcIjB4XCIgKyB0aGlzLmJ1ZmZlci5zbGljZShHVUlEX09GRlNFVCkudG9TdHJpbmcoXCJoZXhcIik7XG4gIH1cbiAgaGVhZGVyKCkge1xuICAgIHJldHVybiBcIjB4XCIgKyB0aGlzLmJ1ZmZlci5zbGljZSgwLCBHVUlEX09GRlNFVCkudG9TdHJpbmcoXCJoZXhcIik7XG4gIH1cbiAgaGVhZGVySGFzaCgpIHtcbiAgICByZXR1cm4ga2VjY2FrMjU2LmtlY2NhazI1Nih0aGlzLmhlYWRlcigpKTtcbiAgfVxuICAvKipcbiAgICogZGVzZXJpYWxpemUgcGFja2V0IGZyb20gaGV4IHN0cmluZ1xuICAgKiBAZGVwcmVjYXRlZCB1c2UgdG9QYWNrZXQgaW5zdGVhZFxuICAgKi9cbiAgZGVjb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnRvUGFja2V0KCk7XG4gIH1cbiAgdG9QYWNrZXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbigpLFxuICAgICAgbm9uY2U6IHRoaXMubm9uY2UoKSxcbiAgICAgIHNyY0VpZDogdGhpcy5zcmNFaWQoKSxcbiAgICAgIHNlbmRlcjogdGhpcy5zZW5kZXIoKSxcbiAgICAgIGRzdEVpZDogdGhpcy5kc3RFaWQoKSxcbiAgICAgIHJlY2VpdmVyOiB0aGlzLnJlY2VpdmVyKCksXG4gICAgICBndWlkOiB0aGlzLmd1aWQoKSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSgpLFxuICAgICAgLy8gZGVyaXZlZFxuICAgICAgcGF5bG9hZDogdGhpcy5wYXlsb2FkKClcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gY2FsY3VsYXRlR3VpZChwYWNrZXRIZWFkKSB7XG4gIHJldHVybiBrZWNjYWsyNTYua2VjY2FrMjU2KFxuICAgIHNvbGlkaXR5LnBhY2soXG4gICAgICBbXCJ1aW50NjRcIiwgXCJ1aW50MzJcIiwgXCJieXRlczMyXCIsIFwidWludDMyXCIsIFwiYnl0ZXMzMlwiXSxcbiAgICAgIFtcbiAgICAgICAgYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKHBhY2tldEhlYWQubm9uY2UpLFxuICAgICAgICBwYWNrZXRIZWFkLnNyY0VpZCxcbiAgICAgICAgYWRkcmVzc1RvQnl0ZXMzMihwYWNrZXRIZWFkLnNlbmRlciksXG4gICAgICAgIHBhY2tldEhlYWQuZHN0RWlkLFxuICAgICAgICBhZGRyZXNzVG9CeXRlczMyKHBhY2tldEhlYWQucmVjZWl2ZXIpXG4gICAgICBdXG4gICAgKVxuICApO1xufVxuXG4vLyBzcmMvY29kZWMvcGFja2V0LXNlcmlhbGl6ZXIudHNcbnZhciBQYWNrZXRTZXJpYWxpemVyID0gY2xhc3Mge1xuICBzdGF0aWMgc2VyaWFsaXplKHBhY2tldCkge1xuICAgIHJldHVybiBQYWNrZXRWMUNvZGVjLmVuY29kZShwYWNrZXQpO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlc0xpa2UpIHtcbiAgICBsZXQgY29kZWM7XG4gICAgaWYgKGJ5dGVzTGlrZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGNvZGVjID0gUGFja2V0VjFDb2RlYy5mcm9tQnl0ZXMoYnl0ZXNMaWtlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZWMgPSBQYWNrZXRWMUNvZGVjLmZyb20oYnl0ZXNMaWtlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVjLnRvUGFja2V0KCk7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImtlY2NhazI1NlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ga2VjY2FrMjU2LmtlY2NhazI1NjsgfVxufSk7XG5leHBvcnRzLkV4ZWN1dG9yT3B0aW9uVHlwZSA9IEV4ZWN1dG9yT3B0aW9uVHlwZTtcbmV4cG9ydHMuT3B0aW9uVHlwZSA9IE9wdGlvblR5cGU7XG5leHBvcnRzLk9wdGlvbnMgPSBPcHRpb25zO1xuZXhwb3J0cy5QYWNrZXRTZXJpYWxpemVyID0gUGFja2V0U2VyaWFsaXplcjtcbmV4cG9ydHMuUGFja2V0VjFDb2RlYyA9IFBhY2tldFYxQ29kZWM7XG5leHBvcnRzLlZlcmlmaWVyT3B0aW9uVHlwZSA9IFZlcmlmaWVyT3B0aW9uVHlwZTtcbmV4cG9ydHMuV29ya2VySWQgPSBXb3JrZXJJZDtcbmV4cG9ydHMuYWRkcmVzc1RvQnl0ZXMzMiA9IGFkZHJlc3NUb0J5dGVzMzI7XG5leHBvcnRzLmJ5dGVzMzJUb0V0aEFkZHJlc3MgPSBieXRlczMyVG9FdGhBZGRyZXNzO1xuZXhwb3J0cy5jYWxjdWxhdGVHdWlkID0gY2FsY3VsYXRlR3VpZDtcbmV4cG9ydHMuaGV4WmVyb1BhZFRvMzIgPSBoZXhaZXJvUGFkVG8zMjtcbmV4cG9ydHMuaXNTb2xhbmFBZGRyZXNzID0gaXNTb2xhbmFBZGRyZXNzO1xuZXhwb3J0cy5vcHRpb25zVHlwZTEgPSBvcHRpb25zVHlwZTE7XG5leHBvcnRzLm9wdGlvbnNUeXBlMiA9IG9wdGlvbnNUeXBlMjtcbmV4cG9ydHMucGFja2V0VG9NZXNzYWdlT3JpZ2luID0gcGFja2V0VG9NZXNzYWdlT3JpZ2luO1xuZXhwb3J0cy5wYXJzZUVycm9yID0gcGFyc2VFcnJvcjtcbmV4cG9ydHMucGFyc2VQcmVjcmltZUNvbmZpZyA9IHBhcnNlUHJlY3JpbWVDb25maWc7XG5leHBvcnRzLnRyaW0weCA9IHRyaW0weDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW91dC5qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@layerzerolabs/lz-v2-utilities/dist/index.cjs\n");

/***/ })

};
;